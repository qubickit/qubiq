# QubicKit Contract Payloads

This folder is entirely generated by `scripts/gen-contract-types.ts`. It mirrors the official C++ contracts and gives you strongly typed payloads plus layout metadata for each registered `*_input` / `*_output` struct.

## What gets generated?

```
src/contracts/generated/
├── computor-controlled-fund.ts   # per-contract module
├── qswap.ts                      # another contract module
├── ...                           # one file per header in temp/qubic/core/src/contracts
├── contracts.generated.ts        # aggregator (re-exports everything)
├── MANIFEST.json                 # change log (header → emitted module + counts)
└── README.md                     # this file
```

Each contract module exports:

- `<ContractName>Definition` – JSON metadata with function/procedure IDs and payload struct names
- Interfaces for every payload (e.g., `Qswap_QuoteExactQuInput_input`)
- `<ContractName>StructMap` – contract-scoped struct lookup map
- `<ContractName>StructLayouts` – layout metadata describing the field order/wire types

The aggregator (`contracts.generated.ts`) re-exports all contracts and exposes:

- `CONTRACT_DEFINITIONS`, `CONTRACT_DEFINITION_MAP`, `CONTRACT_DEFINITION_BY_HEADER`
- `STRUCT_LAYOUTS` – merged layouts for every struct in the repo
- `StructFromName<T>` / `GeneratedStructMap` / `StructName` – type helpers when you need to work across multiple contracts

## Using payload types (contract-scoped)

```ts
import {
  ComputorcontrolledfundDefinition,
  ComputorcontrolledfundStructLayouts,
  ComputorControlledFund_GetProposal_input,
} from "@contracts/generated/computor-controlled-fund";
import { createEncodeContext, writeU16, readU16 } from "@contracts/codec";

const payload: ComputorControlledFund_GetProposal_input = { proposalIndex: 42 };
const layout = ComputorcontrolledfundStructLayouts.ComputorControlledFund_GetProposal_input;

const ctx = createEncodeContext(2);
writeU16(ctx, payload.proposalIndex);
const encoded = ctx.buffer;

const view = new DataView(encoded.buffer);
const { value: proposalIndex } = readU16(view, 0);
```

## Using the aggregator (cross-contract helpers)

```ts
import {
  CONTRACT_DEFINITIONS,
  STRUCT_LAYOUTS,
  StructFromName,
} from "@contracts/generated/contracts.generated";
import { writeU16, createEncodeContext } from "@contracts/codec";

type GetProposalInput = StructFromName<"ComputorControlledFund_GetProposal_input">;
const payload: GetProposalInput = { proposalIndex: 7 };

const layout = STRUCT_LAYOUTS["ComputorControlledFund_GetProposal_input"];
const ctx = createEncodeContext(2);
writeU16(ctx, payload.proposalIndex);
```

> **Tip:** When you only need one contract, import from `@contracts/generated/<contract>`. Switch to the aggregator once you build shared utilities (e.g., automation queues, CLI commands) so helpers auto-adapt to new contracts.

## Real-world example: QSwap quote

```ts
import type { Qswap_QuoteExactQuInput_input } from "@contracts/generated/qswap";
import { QswapStructLayouts } from "@contracts/generated/qswap";
import { createEncodeContext, writeId, writeU64 } from "@contracts/codec";
import { identityToPublicKey } from "@wallet/identity";

const payload: Qswap_QuoteExactQuInput_input = {
  assetIssuer: identityToPublicKey("XQCLNHCEHTKQZDBA..."),
  assetName: 327647778129n,
  quAmountIn: 1_000_000_000n,
};

const layout = QswapStructLayouts.Qswap_QuoteExactQuInput_input;
const ctx = createEncodeContext(32 + 8 + 8);
writeId(ctx, payload.assetIssuer);
writeU64(ctx, payload.assetName);
writeU64(ctx, payload.quAmountIn);
const encoded = ctx.buffer;
```

## Manifest & diffing

- `MANIFEST.json` lists every header processed, which `.ts` file was emitted, and how many user functions/procedures were discovered. Use it in PRs to quickly spot upstream contract changes.
- Regenerate any time upstream headers change:
  ```bash
  bun scripts/gen-contract-types.ts
  ```

## Developer workflow tips

1. **Start narrow** – work in the per-contract module for trusted autocomplete.
2. **Promote to shared helpers** – once logic should work across contracts, import from the aggregator and rely on `StructFromName` / `STRUCT_LAYOUTS`.
3. **Treat layouts as the source of truth** – never hard-code offsets; iterate over layout metadata and call the matching codec helper (`writeU64`, `writeBool`, `writeBytes`, etc.).
4. **Add codecs as needed** – a new field type? Extend `src/contracts/codec.ts` once and reuse it everywhere.
5. **Watch the manifest** – new contract functions will show up as manifest diffs even before you run integration tests.
