---
title: Testing & Fixtures
description: Validate integrations with mocks, snapshot replays, and optional smoke tests.
---

The repo ships batteries-included testing utilities so SDKs or downstream libraries can verify behavior without hitting the live network.

## Mock live service

```ts
import { MockLiveServiceClient } from "@nexakit/core/testing";

const mock = new MockLiveServiceClient();
mock.enqueueBalance("SUZ...", { balance: "1000" });
expect((await mock.getBalance("SUZ...")).balance.balance).toBe("1000");
```

Swap the mock into your unit tests to avoid network calls.

## Snapshot fixtures

```ts
import { HistoricalTickSnapshots, replayTickSnapshots } from "@nexakit/core/testing";

await replayTickSnapshots(HistoricalTickSnapshots, async (sample) => {
  console.log(sample.tick);
}, { delayMs: 10 });
```

Fixtures cover both tick metadata and transaction histories (`HistoricalTransactionSnapshots`). Use them to stress pipelines or serialization logic deterministically.

## Replay helpers

```ts
import { replayTransactionSnapshots } from "@nexakit/core/testing";

await replayTransactionSnapshots(HistoricalTransactionSnapshots, async (tx) => {
  queue.enqueue({ destinationPublicKey: tx.destination, amount: BigInt(tx.amount) });
}, { loop: true, delayMs: 5 });
```

Replays respect abort signals and loop options so you can simulate busy periods.

## Smoke tests

Two opt-in tests hit public endpoints to ensure connectivity:

```bash
QUBIC_SMOKE_TESTS=true bun test tests/smoke/live-service-smoke.test.ts
```

They fetch `/v1/tick-info` and `/v1/balances/{id}` using the production API. Keep them off in CI unless you explicitly need to validate environments.

## Helpful commands

| Command | Description |
| --- | --- |
| `bun run lint` | Type-check + Biome | 
| `bun test` | Runs all unit & integration tests |
| `QUBIC_SMOKE_TESTS=true bun test` | Includes live smoke tests |

Check `tests/automation`, `tests/wallet`, `tests/proposals`, and `tests/serialization` for real examples of mocking + replay patterns.
