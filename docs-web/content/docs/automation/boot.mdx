---
title: Boot Management
description: Decide when to re-sync vs. reuse cached state with BootManager and friends.
---

`@qubickit/core/boot` ships a small orchestration layer that mirrors the native node’s boot flags. It’s ideal for validators, custodial services, or automation daemons that need to resume safely after downtime.

## BootManager

```ts
import { BootManager, BootMode } from "@qubickit/core/boot";

const manager = new BootManager({
  persistPath: ".qubic/boot-state.json",
});

const decision = await manager.decide();
if (decision.mode === BootMode.Scratch) {
  console.log("Start clean sync", decision.reason);
} else {
  console.log("Resume from cached state");
}
```

- Persists the last successful epoch (`FileBootStateStore`).
- Queries live/query services to compare epochs and detect gaps.
- Honors overrides: `forcedMode`, `desiredEpoch`, `requireCleanState`.

<details>
  <summary>Decision flow</summary>

1. Forced mode? Use it immediately.
2. Missing state or clean state requested? Go scratch.
3. Remote epoch > stored epoch + 1? Go scratch to avoid divergence.
4. Otherwise run seamless boot.

</details>

## Boot state stores

- `FileBootStateStore` (default) keeps JSON on disk.
- Implement `BootStateStore` to back Redis, S3, or database tables.
- Multiple workers can share one store to coordinate restarts.

## Client hooks

Inject custom `LiveServiceClient` / `QueryServiceClient` instances for air-gapped setups:

```ts
const manager = new BootManager({
  liveClient: new LiveServiceClient({ baseUrl: process.env.LIVE_URL }),
  queryClient: new QueryServiceClient({ baseUrl: process.env.QUERY_URL }),
});
```

## Putting it together

- Run `BootManager.decide()` before launching long-running connectors or automation runtimes.
- Store the resulting flag inside provisioning scripts (Kubernetes configmaps, systemd env vars, etc.).
- Emit telemetry whenever mode changes so you can alert on repeated scratch boots.
